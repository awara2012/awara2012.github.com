
### 关于消息队列的一切

[TOC]

#### <a name="消息队列的本质"></a>一、消息队列的本质

1. 一次RPC变成两次RPC：适时异步处理
2. 内容转储：可持久化、备份
3. 选择合适的时机再投递：缓冲区

#### <a name="基础概念"></a>二、基础概念

1. 发布-订阅模式/观察者模式

2. 消息队列的基本组建：
    - Broker：消息存储和路由控制；
    - Producer：消息的生产控制；
    - Consumer：消息的消费控制；

3. 消息模型：
    - 队列模型（P2P）：消费者从Queue中读取消息，且每个消息只被其中一个读取；
    - 广播模型（Topic）：消息被广播给订阅此Topic的所有消费者。

4. 特点：消息驱动，异步处理

5. 优点：
    - 减少请求响应时间（非阻塞异步处理）
    - 防流量高峰，流量削峰（缓冲区）
    - 系统解耦（分布式系统间异步通讯）
    - 数据同步（发布-订阅）
    - 避免资源竞争（（局部）有序性）
    - 分布式系统的优点：扩展性（集群）、容错性/无单点故障（持久化，备份）

6. 消息队列（MessageQueue）和消息总线（EventBus）的本质区别？
    - 基本同RPC和底层网络通信协议的关系；
    - 总线的优势：统一入口，简化拦截成本；
    - 总线：所谓的总线就是进行先收拢再发散的过程。先收拢，从统一的入口进去，完成必要的统一处理逻辑；再发散，按照路由规则，路由到各个组件去处理。事实上这就是代理的作用：屏蔽内部细节，对外统一入口。在基于代理的基础上，我们可以对消息总线上所有的消息做日志记录（因为所有消息的通信都必须经过代理），并且还是在不切断RabbitMQ自身Channel的基础上，而如果想在路由上实现一个Proxy，那基本上离不开一个树形拓扑结构。

#### <a name="消息队列的特性"></a>三、消息队列的特性

- 分布式系统基本特性：一致性（最终一致性）、容错性、可用性、扩展性

##### <a name="基本特性"></a>1、基本特性

1.1 消息发送方式：同步 vs. 异步

    - 同步发送消息
    - 异步发送消息：消息延时投递；可配置producer使得在一定时间后发送消息，或是消息累积到一定量后再发送；

1.2 消息消费方式：Pull vs. Push

- Pull模型：consumer端可以根据自身情况，控制消费速度（适时的取消息并处理，且可以控制消息消费的进度），以及选择消费模式（批量，重复消费，从尾端开始消费等）；可以根据consumer的消费能力以适当的速率消费消息；
- Push模型：消息发送速率是由broker决定，很难适应消费速率不同的消费者；目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞；

1.3 顺序保证（时序性）：

- 全局有序：严格的FIFO；全局唯一的、单调递增的、连续的序列号；
- 局部有序：分区有序；
- 无序（乱序）

Akka Mailbox：单队列多线程的架构，要想任务有序只能一个单一线程去处理有序任务，也就是说你往队列里扔的任务本身又是一个小队列，这个队列只能被一个线程执行。

在应用层面处理：如果queue只有单一worker，且能通过发布端控制或者通过MQ本身的routing机制将相同组的消息发到同一个queue，那就相对比较简单。

1.4 消息投递（消费）保证（delivery guarantee semantic）

从生产者和消费者两个角度来阐述消息的投递（消费）保证。

消息投递（消费）保证（QoS 服务质量）：

- `最多一次（at most once）`：不重复投递，有丢失消息的概率；使用`fire-and-forget方式（tell）`；性能最高，实现开销最少，不需要在发送端或传输机制中保留状态；

- `最少一次（at least once）`：消息可能重复，但不会丢失；使用`ack-retry方式（ask）`；要求重试来对抗传输丢失，需要在发送端保持状态，并在接收端使用确认机制；

- `有且仅有一次（exactly once）`：不会重复，也不会丢失；使用`check-and-discard方式`；性能最差，除了需要第二种方式的机制以外，还需要在接收端保持状态，以过滤重复投递的消息；还使用分布式事务（2PC/3PC）方式。

> `ack-retry协议`：用来保证“有且仅有一次”的投递(消费)语义

> i、一种方法来识别个体信息，并将它与确认进行关联；

> ii、一个重试机制，如果没有及时确认，将重新发送消息；

> iii、一种接收方用来检测和丢弃重复消息的方法。或者在业务逻辑中实现消息处理的幂等性（即每次消息处理的结果都是一样的）。

消息从broker道consumer的消费保证,在很大程度上由数据处理与commit的顺序决定了。

`幂等性`

1.5 事务特性

- `确认机制`：生产确认和消费确认，保证“最少一次”；
- `检测丢弃重复消息机制` / `消息幂等性`：检测和丢弃重复消息,或幂等处理消息，保证“最多一次”；
- `确认机制` + `检测丢弃重复消息机制`：保证“有且仅有一次”；
- `确认机制` + `消息幂等性`：保证“有且仅有一次”；

`事件源（event-sourcing）`：组件的状态丢失时，通过重播事件流（通常使用快照来加快处理）进行重建

1.6 消息处理模式：one-by-one vs. batch

- `batch模式`：批量拉取模式下线程池消费可能会造成消费顺序混乱的问题；

1.7 队列模型：FIFO队列、优先队列、延迟队列

1.8 持久化：同步写 vs. 异步写、随机读写 vs. 顺序读写

1.9 数据备份

i、备份模式：主从模式、主备模式、主主模式（镜像队列 mirror queue）
ii、副本数
iii、副本同步策略：同步复制、异步复制
iv、副本写入成功后确认

1.10 数据有效期策略

1.11 集群特性

1.12 负载均衡：

1）rebalance
2）控制负载均衡：broker vs. client

##### <a name="扩展特性"></a>2、扩展特性

- 堆积能力
- 延迟敏感度
- 错峰流控能力
- 慢消息处理

- 过载机制：丢弃新消息（即拒绝新的消息）、丢弃旧消息

- 队列控制策略 (admission control policy) ：backpressure（通过阀值、速率控制是否入队还是阻塞）、服务降级、丢弃；
- 队列管理算法：
i、被动式队列管理（Passive Queue Management，PQM）
ii、主动式队列管理（Active Queue Management，AQM）
http://www.cnblogs.com/redsmith/p/5461713.html
http://blog.csdn.net/shoren80/article/details/8967091


#### <a name="消息队列主要组件"></a>四、消息队列主要组件

- RPC通讯协议：序列化
- 存储选型：内存和磁盘；顺序文件和数据库；
- 消费关系处理：P2P、Topic
- 实现事务
- 防丢和防重
- 批量/异步与性能

5、MQ实现：
1）Producer、Consumer/ConsumerGroup、Broker、Message
2）Topic和Queue
3）Header（头字段/属性）：
- MessageID
- Timestamp
- Destination（目的地）
- DeliveryMode（转发模式）
- Type
- Expiration
- Priority
4）Routing（路由）

#### <a name="消息队列应用"></a>五、消息队列应用

消息队列主要用于将比较耗时（阻塞）且不需要即时返回结果（同步）的操作作为消息放入消息队列中异步处理。

典型的使用场景包括：

- 数据复制
- 日志聚合和处理
- 广播通知
- 分布式事务

#### <a name="消息队列协议规范"></a>六、消息队列协议规范

##### <a name="AMQP"></a>1、AMQP

- 独立于平台的底层消息传递协议
- 消费者驱动消息传递
- 跨语言和平台的互用性
- 它是底层协议的
- 有5种交换类型direct，fanout，topic，headers，system
- 面向缓存的
- 可实现高性能
- 支持长周期消息传递
- 支持经典的消息队列，循环，存储和转发
- 支持事务（跨消息队列）
- 支持分布式事务（XA，X/OPEN，MS DTC）
- 使用SASL和TLS确保安全性
- 支持代理安全服务器
- 元数据可以控制消息流
- 不支持LVQ
- 客户端和服务端对等
- 可扩展

##### <a name="JMS"></a>2、JMS

- 面向Java平台的标准消息传递API
- 在Java或JVM语言比如Scala、Groovy中具有互用性
- 无需担心底层协议
- 有queues和topics两种消息传递模型
- 支持事务
- 能够定义消息格式（消息头、属性和内容）

##### <a name="MQTT"></a>3、MQTT

- 基于TCP长连接
- 面向流（二进制格式），内存占用低
- 为小型无声设备之间通过低带宽发送短消息而设计
- 不支持长周期存储和转发
- 不允许分段消息（很难发送长消息）
- 支持主题发布-订阅
- 不支持事务（仅基本确认）
- 消息实际上是短暂的（短周期）
- 简单用户名和密码，基于没有足够信息熵的安全
- 不支持安全连接
- 消息不透明
- Topic是全局的（一个全局的命名空间）
- 支持LVQ（Last Value Queue 最新值队列）
- 客户端和服务端不对称
- 不能扩展
使用发布/订阅消息模式，提供一对多的消息分发，解除了应用程序之间的耦合；
对负载内容屏蔽的消息传输；
使用 TCP/IP 提供基础的网络连接；
有三种级别的消息传递服务；
小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；
提供一种机制，使得客户端异常中断时，能够使用 LastWill 和 Testament 特性通知有关各方。
http://dataguild.org/?p=6817

##### <a name="CoAP"></a>4、CoAP

- 基于UDP数据报

##### <a name="XMPP"></a>5、XMPP

http://www.elecfans.com/iot/421799_a.html


#### <a name="各种消息队列之间的比较"></a>七、各种消息队列之间的比较
|MQ|描述|架构模型（pull/push）|性能（吞吐量）|持久化|数据备份模式|实现语言|支持的语言|顺序保证|事务支持|可用性|集群负载均衡等|
|:--:|-----------|
|`RabbitMQ`||
|`ActiveMQ`||
|`Kafka`||
|`RockectMQ`||
|`NSQ`||
|`Disque`||
|`Kestrel`||
|`DistributedLog`||
|`Disruptor`||
|`ZeroMQ`||

http://soledede.iteye.com/blog/1974988
http://blog.jobbole.com/45547/

#### <a name="消息队列的选择"></a>七、消息队列的选择

- 是否持久化
- 吞吐能力
- 高可用：避免单点故障
- 分布式扩展能力：负载均衡
- 兼容现有协议
- 易于维护
- 其他：消息丢失和重复的处理

#### <a name="参考文献"></a>参考文献

- [消息队列设计精要](http://tech.meituan.com/mq-design.html)
